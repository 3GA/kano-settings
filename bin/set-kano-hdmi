#!/usr/bin/env python

import os
import sys
from kano.utils import read_file_contents_as_lines, run_cmd, delete_file, write_file_contents, \
    enforce_root
from kano.logging import logger

tvservice_path = '/usr/bin/tvservice'
config_txt_path = '/boot/config.txt'
edid_dat_path = '/tmp/edid.dat'

pi_detected = os.path.exists(tvservice_path) and os.path.exists(config_txt_path)


# acquiring edid
if pi_detected:
    # loading config_txt
    config_txt = read_file_contents_as_lines(config_txt_path)

    status_str, _, _ = run_cmd(tvservice_path + ' -s')
    if 'DMT' in status_str:
        status_group = 'DMT'
    elif 'CEA' in status_str:
        status_group = 'CEA'
    else:
        logger.error('status parsing error')
        sys.exit()
    status_mode = status_str.split('(')[1].split(')')[0].strip()
    status_full_range = 'RGB full' in status_str
    status_overscan = 'disable_overscan=1' not in config_txt


if len(sys.argv) > 1 and '--force' not in sys.argv:
    file_path = sys.argv[1]
    if not os.path.exists(file_path):
        logger.error('file doesn\'t exist')
        sys.exit()
    edid_data = read_file_contents_as_lines(file_path)
else:
    if not pi_detected:
        logger.error('specify edid.txt file or run on the Pi')
        sys.exit()
    delete_file(edid_dat_path)
    edid_data, _, rc = run_cmd('tvservice -d {0} && edidparser {0}'.format(edid_dat_path))
    edid_data = edid_data.splitlines()
    if rc != 0:
        logger.error('error getting edid dat')
        sys.exit()
    delete_file(edid_dat_path)


# parsing edid
preferred_res = None
screen_size = None
model = None
found = False
dmt_found = False

for l in edid_data:

    # screen size
    if 'screen size' in l:
        screen_size = int(l.split('screen size')[1].split('x')[0].strip())

    # model name
    elif 'monitor name is' in l:
        model = l.split('monitor name is')[1].strip()

    # preferred
    elif 'found preferred' in l:
        if 'DMT' in l:
            preferred_group = 'DMT'
        elif 'CEA' in l:
            preferred_group = 'CEA'
        else:
            logger.error('parsing error')
            sys.exit()

        res, mode = l.split(':')[2].split('@')
        preferred_res = res.strip()
        hz, mode = mode.split(' Hz (')
        preferred_hz = hz.strip()
        preferred_mode = mode[:-1]

    # moving support
    elif 'moving support for' in l:
        found_group, found_mode = l.split(' to ')[1].split(' because sink')[0].split('mode')
        found_group = found_group.strip()
        found_mode = found_mode.strip()
        found = True

    # dmt_found
    elif preferred_res and preferred_group == 'CEA' and preferred_res in l and 'remained' not in l:
        if 'DMT' not in l:
            continue

        tmp_hz = l.split('@')[1].split('Hz')[0].strip()
        if tmp_hz != preferred_hz:
            continue

        dmt_found = True


# setting target mdoe
if found:
    target_group = found_group
    target_mode = found_mode
else:
    target_group = preferred_group
    target_mode = preferred_mode


# is_monitor
if target_group == 'DMT':
    is_monitor = True
else:
    if dmt_found or screen_size < 60:
        is_monitor = True
    else:
        is_monitor = False


# hard coded overwrites
if model == '32V3H-H6A':
    # found_res = '1024x768p'
    # found_hz = '60'
    target_group = 'DMT'
    target_mode = '16'
    is_monitor = True

if model == 'BMD_HDMI':
    # found_res = '1920x1080p'
    # found_hz = '25'
    target_group = 'CEA'
    target_mode = '33'
    is_monitor = True


# is_monitor calculations
if is_monitor:
    target_full_range = True
else:
    target_full_range = False

# always disable overscan
target_overscan = False


# printing to screen
logger.error('{} size: {} cm'.format(model, screen_size))

if pi_detected:
    logger.error('status\t{} {} full_range: {} overscan: {}'.format(status_group, status_mode, status_full_range, status_overscan))

logger.error('preferred\t{} {}'.format(preferred_group, preferred_mode))

if found:
    logger.error('found\t{} {}'.format(found_group, found_mode))

logger.error('target\t{} {} full_range: {} overscan: {}'.format(target_group, target_mode, target_full_range, target_overscan))
logger.error('is_monitor: \t{}'.format(is_monitor))


# applying changes
if not pi_detected:
    sys.exit()

config_change_needed = False
config_hdmi_group = None
config_hdmi_mode = None
config_hdmi_pixel_encoding = None
config_disable_overscan = None

if status_group == target_group and status_mode == target_mode:
    logger.error('mode change not needed')
else:
    config_change_needed = True

    logger.error('mode change needed')
    logger.error('\tsetting mode: {} {}'.format(target_group, target_mode))
    if target_group == 'CEA':
        config_hdmi_group = '1'
    else:
        config_hdmi_group = '2'

    config_hdmi_mode = target_mode

if status_full_range == target_full_range:
    logger.error('fullrange change not needed')
else:
    config_change_needed = True

    logger.error('fullrange change needed')
    logger.error('setting fullrange to: {}'.format(target_full_range))
    if target_full_range:
        config_hdmi_pixel_encoding = '2'
    else:
        config_hdmi_pixel_encoding = '0'

if status_overscan == target_overscan:
    logger.error('overscan change not needed')
else:
    config_change_needed = True

    logger.error('overscan change needed')
    logger.error('setting overscan to: {}'.format(target_overscan))
    if target_overscan:
        config_disable_overscan = '0'
        default_overscan_value = -48
    else:
        config_disable_overscan = '1'
        default_overscan_value = 0

if not config_change_needed:
    logger.error('no config needed, not modifying config.txt')
    sys.exit()
else:
    logger.error('modifying config.txt')


# modifying config.txt

# checking root
enforce_root('Need to be root!')

# checking if already set
kano_screen_saved_comment = '### kano_screen_used: {}'.format(model)
if config_txt[0] == kano_screen_saved_comment and '--force' not in sys.argv:
    logger.error('screen already set in config.txt, skipping screen override')
    sys.exit()

# creating new config_txt
config_txt_new = list()
config_txt_new.append(kano_screen_saved_comment)
for l in config_txt:

    # hdmi_group
    if 'hdmi_group' in l and config_hdmi_group:
        line = 'hdmi_group={}'.format(config_hdmi_group)
        logger.error('writing hdmi_group')

    # hdmi_mode
    elif 'hdmi_mode' in l and config_hdmi_mode:
        line = 'hdmi_mode={}'.format(config_hdmi_mode)
        logger.error('writing hdmi_mode')

    # hdmi_pixel_encoding
    elif 'hdmi_pixel_encoding' in l and config_hdmi_pixel_encoding:
        line = 'hdmi_pixel_encoding={}'.format(config_hdmi_pixel_encoding)
        logger.error('writing hdmi_pixel_encoding')

    # disable_overscan
    elif 'disable_overscan' in l and config_disable_overscan:
        line = 'disable_overscan={}'.format(config_disable_overscan)
        logger.error('writing disable_overscan')

    elif 'overscan_left' in l and config_disable_overscan:
        line = 'overscan_left={}'.format(default_overscan_value)

    elif 'overscan_right' in l and config_disable_overscan:
        line = 'overscan_right={}'.format(default_overscan_value)

    elif 'overscan_top' in l and config_disable_overscan:
        line = 'overscan_top={}'.format(default_overscan_value)

    elif 'overscan_bottom' in l and config_disable_overscan:
        line = 'overscan_bottom={}'.format(default_overscan_value)

    # deleting kano_screen_used
    elif 'kano_screen_used' in l:
        continue

    # keeping other lines intact
    else:
        line = l

    config_txt_new.append(line)

config_txt_new = '\n'.join(config_txt_new)
write_file_contents(config_txt_path, config_txt_new)


# reboot
run_cmd('reboot')
