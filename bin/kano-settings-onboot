#!/usr/bin/env python

# check-enable-ssh
#
# Copyright (C) 2017 Kano Computing Ltd.
# License: http://www.gnu.org/licenses/gpl-2.0.txt GNU GPL v2
#
# TODO: Description


"""
kano-settings-onboot TODO: Description

Usage:
    kano-settings-onboot [options]

Options:
    -f, --force         TODO: Description
    -s, --dry-run       TODO: Description
    -h, --help          Show this message.
"""


import os
import sys
import docopt

# Allows for testing this module from a local repository clone
if __name__ == '__main__' and __package__ is None:
    dir_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
    if dir_path != '/usr':
        sys.path.insert(0, dir_path)

from kano.utils.shell import run_cmd
from kano.utils.hardware import get_rpi_model, get_board_property
from kano.logging import logger

from kano_settings.system.display import get_status, get_edid_name, \
    get_edid, list_supported_modes, override_models, compare_and_set_full_range, \
    compare_and_set_overscan, compare_and_set_optimal_resolution
from kano_settings.system.boot_config.boot_config_filter import Filter
from kano_settings.boot_config import set_config_comment, is_safe_boot, \
    safe_mode_restore_config, remove_noobs_defaults, end_config_transaction, \
    check_corrupt_config, get_config_value
from kano_settings.system.audio import is_HDMI, set_to_HDMI
from kano_settings.system.overclock_chip_support import check_clock_config_matches_chip

from kano_settings.return_codes import RC_SUCCESS, RC_REQUIRES_ROOT, RC_INCORRECT_ARGS, \
    RC_EDID_NO_MODEL, RC_EDID_NO_STATUS, RC_EDID_NO_SUPPORTED


def main(args):

    force_mode = args['--force']
    dry_run = args['--dry-run']

    reboot_now = False

    # TODO: Move this task away, it is not related to screen management
    ensure_correct_browser(dry_run=dry_run)

    # Check for corrupt config file
    if check_corrupt_config():
        logger.warning('Found corrupt config file! Restored to default.')
        reboot_now = True

    # Rpi1 and Rpi2 have different clock rate defaults, but only one
    # set of config options. Swap the config options if we have booted
    # on the other chip.
    if check_clock_config_matches_chip():
        logger.info('Adjusted clock speeds for new chipset.')
        reboot_now = True

    # If we are in NOOBS mode, remove the config lines generated by noobs
    # because they duplicate our config entries and override them and
    # we expect only one instance of a config entry.
    if remove_noobs_defaults():
        logger.info('Removed NOOBS config.txt defaults.')
        reboot_now = True

    # If we need to set anything to do with config.txt, reboot
    if reboot_now:
        end_config_transaction()
        logger.debug('Changes were made to config.txt, rebooting.')
        reboot(dry_run=dry_run)
        return RC_SUCCESS

    # TODO: Why isn't this above the reboot and config modifications?
    if is_safe_boot():
        logger.info('In safe boot mode, restoring config.txt, skipping autoconfig.')
        safe_mode_restore_config()
        end_config_transaction()
        return RC_SUCCESS

    # Gather and log data about the current screen
    # screen_data = get_screen_information(dry_run=dry_run)
    # if verbose or dump_mode:
    #     print json.dumps(screen_data, indent=4)

    # If the display model cannot be retrieved it is a strong indication that
    # the screen is unflashed or the EDID is corrupt.
    model = get_edid_name()  # TODO: or 'uSK'
    if not model:
        logger.error('Could not get the model of the screen. Will use config.txt defaults.')
        return RC_EDID_NO_MODEL

    # Check if the screen was already configured by looking for the hdmi_mode option
    # set for this display only.
    was_screen_configured = get_config_value(
        'hdmi_mode',
        config_filter=Filter.get_edid_filter(model),
        fallback=False,
        ignore_comments=True
    )
    if was_screen_configured and not force_mode:
        logger.debug('The unit was configured for this model already, exiting.')
        return RC_SUCCESS

    # Sanity checks, we need current screen status, EDID info, and list of display modes.
    status = get_status()
    if not status:
        logger.error('Could not determine current screen status, aborting.')
        return RC_EDID_NO_STATUS

    supported_modes = list_supported_modes()
    if not supported_modes:
        logger.error('Could not determine list of screen supported modes, aborting.')
        return RC_EDID_NO_SUPPORTED

    edid = get_edid()
    if not edid:
        logger.error('No EDID found. Set resolution for an unflashed SK.')
        reboot(dry_run=dry_run)
        return RC_SUCCESS

    # override modes, calculate is_monitor
    override_models(edid, model)
    calculate_is_monitor(edid)

    # Fix HDMI audio status.
    if not edid['hdmi_audio'] and is_HDMI():
        logger.info('HDMI audio not supported on this screen, changing to analogue')
        if not dry_run:
            set_to_HDMI(False)

    # Calculate changes needed...
    changes = compare_and_set_full_range(edid, status, model, dry_run=dry_run)
    changes = changes or compare_and_set_overscan(edid, status, model, dry_run=dry_run)
    changes = changes or compare_and_set_optimal_resolution(edid, status, supported_modes, dry_run=dry_run)

    # ... and reboot if needed.
    if changes:
        reboot(dry_run=dry_run)

    return RC_SUCCESS


def ensure_correct_browser(dry_run=False):
    """
    Makes sure we point to the supported browser
    depending on the Raspberry model performance.
    """
    browser_link = 'x-www-browser'

    model = get_rpi_model()
    arch = get_board_property(model, 'arch')

    chromium_support = arch not in ['armv6']
    browser = 'chromium-browser' if chromium_support else 'epiphany-browser'

    logger.info("Set browser to be: {}".format(browser))
    if dry_run:
        run_cmd('update-alternatives --set {} /usr/bin/{}'.format(browser_link, browser))


# def get_screen_information(screen_log_path='/boot/screen.log', dry_run=False):
    """
    TODO: Decide what to do with this.
    Retrieves the information about the current screen.
    The data will be logged to the bootpartition for
    troubleshooting purposes.
    """
    # info = {
    #     "edid": get_edid(),
    #     "model": get_model(),
    #     "status": get_status(),
    #     "supported": list_supported_modes(stringify=False)
    # }

    # if not dry_run:
    #     with open(screen_log_path, 'w') as f:
    #         json.dump(info, f, sort_keys=True, indent=4, separators=(',', ': '))

    # return info


def calculate_is_monitor(edid):
    """
    TODO: What is this for?
    """
    edid['target_full_range'] = edid['is_monitor']


def reboot(dry_run=False):
    """
    Flush logs to disk and reboot the kit

    TODO: Description
    """
    if not dry_run:
        logger.sync()
        run_cmd('kano-checked-reboot changes systemctl reboot --force')


if __name__ == '__main__':
    logger.force_log_level('info')

    if os.geteuid() != 0:
        logger.error('Program must be executed with root priviledges.')
        sys.exit(RC_REQUIRES_ROOT)

    try:
        args = docopt.docopt(__doc__)
    except docopt.DocoptExit:
        print __doc__
        sys.exit(RC_INCORRECT_ARGS)

    sys.exit(main(args) or RC_SUCCESS)
