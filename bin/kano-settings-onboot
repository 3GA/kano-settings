#!/usr/bin/env python
#
# kano-settings-onboot
#
# Copyright (C) 2014, 2015, 2017 Kano Computing Ltd.
# License: http://www.gnu.org/licenses/gpl-2.0.txt GNU General Public License v2
#
# Configure HDMI settings on boot.
# Also calls code to set clock config, to avoid need for an extra reboot.
# TODO: Explain better what this tool is actually doing.
#
# Available options:
#
#  --dry-run   : do not change anything, just say what it would be done
#                call "sudo kano-logs config -l debug -o debug"
#  --verbose   : explain more things to the terminal
#  --force     : apply changes even if they are not needed
#  --dump      : dump the screen information and exit (used to --test)
#  --test:file : use --dump data for testing specific screens
#
# Exit code is 0 if the screen has been reconfigured, non-zero otherwise.
# Advise to take a backup copy of /boot/config.txt before running --test modes.
#

import os
import sys
import shutil
import json


# Allows for testing this module from a local repository clone
if __name__ == '__main__' and __package__ is None:
    dir_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
    if dir_path != '/usr':
        sys.path.insert(1, dir_path)

from kano.utils import run_cmd, enforce_root
from kano.logging import logger
from kano_settings.system.display import get_status, get_model, set_hdmi_mode, \
    get_edid, is_mode_fallback, set_safeboot_mode, set_screen_value, list_supported_modes
from kano_settings.boot_config import set_config_value, set_config_comment, \
    get_config_comment, get_config_value, has_config_comment, \
    enforce_pi, is_safe_boot, safe_mode_backup_config, \
    safe_mode_restore_config, remove_noobs_defaults, set_dry_run, \
    end_config_transaction, check_corrupt_config
from kano_settings.system.audio import is_HDMI, set_to_HDMI
from kano_settings.system.overclock_chip_support import check_clock_config_matches_chip
from kano.utils.hardware import get_rpi_model, get_board_property


def check_model_present(model):
    '''
    Returns True if the requested screen model is active
    '''
    if get_config_comment('kano_screen_used', model):
        return True
    else:
        return False


def override_models():
    '''
    This function sets specific modes for screens that require special treatment
    '''
    overrides = {
        '32V3H-H6A':     { 'target_group': 'DMT', 'target_mode': 16, 'is_monitor': True },
        'AS4637_______': { 'target_group': 'DMT', 'target_mode': 16, 'is_monitor': True },
        'BMD_HDMI':      { 'target_group': 'CEA', 'target_mode': 33, 'is_monitor': True },
        }

    global edid, model

    for override_model, override_rules in overrides.iteritems():
        if override_model == model:
            edid['target_group'] = override_rules['target_group']
            edid['target_mode'] = override_rules['target_mode']
            edid['is_monitor'] = override_rules['is_monitor']
            return


def calculate_is_monitor():
    global edid
    edid['target_full_range'] = edid['is_monitor']


def compare_and_set_mode():
    '''
    Returns True if mode is changed
    '''
    global edid, status
    if status['group'] == edid['target_group'] and \
       status['mode'] == edid['target_mode']:
        logger.info('mode change not needed')
        return False
    else:
        logger.info('mode change needed')
        modes = '{} {}'.format(edid['target_group'], edid['target_mode'])
        logger.info('setting mode: {}'.format(modes))

        set_hdmi_mode(edid['target_group'], edid['target_mode'])
        return True


def compare_and_set_full_range():
    '''
    Returns True if full range is changed
    '''
    global edid, status
    if status['full_range'] == edid['target_full_range']:
        logger.info('fullrange change not needed')
        return False
    else:
        logger.info('fullrange change needed')
        msg = 'setting fullrange to: {}'.format(edid['target_full_range'])
        logger.info(msg)

        if edid['target_full_range']:
            set_config_value('hdmi_pixel_encoding', 2)
        else:
            set_config_value('hdmi_pixel_encoding', 0)
        return True


def compare_and_set_overscan():
    '''
    Returns True if overscan is changed
    '''
    global edid, status
    if status['overscan'] == edid['target_overscan']:
        logger.info('overscan change not needed')
        return False
    else:
        logger.info('overscan change needed')
        logger.info('setting overscan to: {}'.format(edid['target_overscan']))

        if edid['target_overscan']:
            set_config_value('disable_overscan', 0)
            overscan_value = -48
        else:
            set_config_value('disable_overscan', 1)
            overscan_value = 0

        set_config_value('overscan_left', overscan_value)
        set_config_value('overscan_right', overscan_value)
        set_config_value('overscan_top', overscan_value)
        set_config_value('overscan_bottom', overscan_value)
        return True


def compare_and_set_optimal_resolution():
    global edid, status, supported

    # collect supported modes, and choose the best "mode".
    return True


def reboot(dry_run=False):
    '''
    Flush logs to disk and reboot the kit
    '''
    if not dry_run:
        logger.sync()
        run_cmd('kano-checked-reboot changes systemctl reboot --force')


def get_screen_information(screen_log_path='/boot/screen.log', dry_run=False):
    '''
    Retrieves the information about the current screen.
    The data will be logged to the bootpartition for
    troubleshooting purposes.
    '''
    info = {
        "edid": get_edid(),
        "model": get_model(),
        "status": get_status(),
        "supported": list_supported_modes(stringify=False)
    }

    if not dry_run:
        with open(screen_log_path, 'w') as f:
            json.dump(info, f, sort_keys=True, indent=4, separators=(',', ': '))

    return info


def ensure_correct_browser():
    '''
    Makes sure we point to the supported browser
    depending on the Raspberry model performance.
    '''
    browser_link='x-www-browser'
    model = get_rpi_model()
    arch = get_board_property(model, 'arch')
    chromium_support = arch not in ['armv6']

    if chromium_support:
        browser = 'chromium-browser'
    else:
        browser = 'epiphany-browser'

    if dry_run:
        logger.debug("browser should be: {}".format(browser))
    else:
        run_cmd('update-alternatives --set {} /usr/bin/{}'.format(browser_link, browser))



if __name__ == '__main__':

    dry_run = '--dry-run' in sys.argv
    force_mode = '--force' in sys.argv
    dump_mode = '--dump' in sys.argv
    verbose = '--verbose' in sys.argv
    test_file = None
    reboot_now = False

    # test mode allows to feed EDID information directly from a custom file
    for arg in sys.argv:
        if arg.startswith('--test:'):
            test_file=arg[7:]
            if not os.path.isfile(test_file):
                logger.error("Cannot find test file: {}".format(test_file))
                sys.exit(1)

    # sanity checks
    logger.force_log_level('info')
    enforce_pi()
    enforce_root('Need to be root!')

    # dry-run mode does not change config.txt file
    if dry_run:
        print "dry_run_mode, not applying any changes"
        set_dry_run()
        logger.force_log_level('debug')
        logger.force_debug_level('debug')

    # TODO: Move this task away, it is not related to screen management
    ensure_correct_browser()

    # Check for corrupt config file
    if check_corrupt_config():
        logger.error("Found corrupt config file! Restoring default.")
        reboot_now = True

    if (test_file):
        # screen information is taken from a --dump data file for testing
        print 'EDID test mode:', test_file
        screen_data = json.loads(open(test_file, 'r').read())
        if verbose:
            print json.dumps(screen_data, indent=4)
    else:
        # Gather and log data about the current screen
        screen_data = get_screen_information(dry_run=dry_run)
        if verbose or dump_mode:
            print json.dumps(screen_data, indent=4)
            if dump_mode:
                exit(1)

    # Rpi1 and Rpi2 have different clock rate defaults, but only one
    # set of config options. Swap the config options if we have booted
    # on the other chip.
    if check_clock_config_matches_chip():
        reboot_now = True

    # If we are in NOOBS mode, remove the config lines generated by noobs
    # Because they duplicate our config entries and override them,
    # we expect only one instance of a config entry.
    if remove_noobs_defaults():
        logger.info("removed NOOBS defaults")
        reboot_now = True

    # Reconfigure and reboot if the user requested safe mode
    # Or if the cable appears not to have been plugged in.
    if is_mode_fallback():
        # Backup the config file and reboot into safe mode
        logger.warn("executing fallback boot")
        safe_mode_backup_config()
        set_safeboot_mode()
        reboot_now = True

    # If we need to set anything to do with config.txt, reboot
    if reboot_now:
        end_config_transaction()
        if dry_run:
            logger.debug("dry run rebooting")
        else:
            reboot(dry_run=dry_run)
        sys.exit(0)

    if is_safe_boot():
        logger.info("In safe boot mode, restoring config.txt, skipping autoconfig")
        safe_mode_restore_config()
        end_config_transaction()
        sys.exit(0)


    # model and model comment check
    # TODO: what is this?
    model = screen_data['model']
    logger.info('Screen model: {}'.format(model))
    if '--force' not in sys.argv and check_model_present(model):
        logger.info('The unit was configured for this model already, exiting.')
        sys.exit(1)

    # Sanity checks, we need current screen status and EDID info
    status = screen_data['status']
    if not status:
        logger.debug("could not determine current screen status, aborting")
        sys.exit(1)

    edid = screen_data['edid']
    if not edid:
        logger.debug("could not determine screen EDID information, aborting")
        sys.exit(1)

    supported = screen_data['supported']
    if not supported:
        logger.debug("could not determine list of screen supported modes, aborting")
        sys.exit(1)

    # If the hdmi_group and hdmi_mode values are set explicitly,
    # then skip the detection.
    if get_config_value('hdmi_group') != 0 and get_config_value('hdmi_mode') != 0:

        logger.info('is comment kano_screen_used? {}'.format(has_config_comment('kano_screen_used')))
        logger.info('is comment kano_screen_used({})? {}'.format(model, get_config_comment('kano_screen_used', model)))

        if not force_mode and (not has_config_comment('kano_screen_used') or \
                                   get_config_comment('kano_screen_used', model)):

            # The screen is either the same or not set at all
            logger.info('Explicit HDMI configuration detected, exiting.')
            sys.exit(1)
        else:
            logger.info('New screen was detected, reconfiguring...')

    # override modes, calculate is_monitor
    override_models()
    calculate_is_monitor()

    if verbose:
        # Explain the new screen settings
        print 'New status:', json.dumps(status, indent=4)
        print 'New EDID:', json.dumps(edid, indent=4)

    # fix hdmi audio status
    if not edid['hdmi_audio'] and is_HDMI():
        logger.info('hdmi audio not supported on this screen, changing to analogue')
        set_to_HDMI(False)

    # calculate changes needed
    changes = compare_and_set_mode() or \
        compare_and_set_full_range() or \
        compare_and_set_overscan() or \
        compare_and_set_optimal_resolution()

    if changes:

        if verbose:
            print 'changes applied:', changes

        # write comment to config
        set_config_comment('kano_screen_used', model)
        end_config_transaction()

        # reboot
        if dry_run:
            logger.debug("dry_run rebooting due to config changes")
        else:
            reboot(dry_run=dry_run)

        sys.exit(0)
    else:
        logger.info('could not calculate changes for screen, nothing done')
        sys.exit(1)
