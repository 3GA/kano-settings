#!/usr/bin/env python

# check-enable-ssh
#
# Copyright (C) 2017 Kano Computing Ltd.
# License: http://www.gnu.org/licenses/gpl-2.0.txt GNU GPL v2
#
# TODO: Description


"""
kano-settings-onboot TODO: Description

Usage:
    kano-settings-onboot [options]

Options:
    -f, --force         TODO: Description
    -s, --dry-run       TODO: Description
    -h, --help          Show this message.
"""


import os
import sys
import json
import docopt

# Allows for testing this module from a local repository clone
if __name__ == '__main__' and __package__ is None:
    dir_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
    if dir_path != '/usr':
        sys.path.insert(0, dir_path)

from kano.utils.shell import run_cmd
from kano.utils.hardware import get_rpi_model, get_board_property
from kano.logging import logger

from kano_settings.system.display import get_status, get_edid_name, set_hdmi_mode, \
    get_edid, is_mode_fallback, set_safeboot_mode, set_screen_value, \
    list_supported_modes, is_screen_kit
from kano_settings.system.boot_config import Filter
from kano_settings.boot_config import set_config_value, set_config_comment, \
    get_config_comment, get_config_value, has_config_comment, \
    enforce_pi, is_safe_boot, safe_mode_backup_config, \
    safe_mode_restore_config, remove_noobs_defaults, set_dry_run, \
    end_config_transaction, check_corrupt_config
from kano_settings.system.audio import is_HDMI, set_to_HDMI
from kano_settings.system.overclock_chip_support import check_clock_config_matches_chip

from kano_settings.return_codes import RC_SUCCESS, RC_REQUIRES_ROOT, RC_INCORRECT_ARGS, \
    RC_EDID_NO_MODEL, RC_EDID_NO_STATUS, RC_EDID_NO_SUPPORTED


def main(args):

    force_mode = args['--force']
    dry_run = args['--dry-run']

    # TODO: Move this task away, it is not related to screen management
    ensure_correct_browser(dry_run=dry_run)

    # Check for corrupt config file
    if check_corrupt_config():
        logger.warning('Found corrupt config file! Restored to default.')
        reboot_now = True

    # Rpi1 and Rpi2 have different clock rate defaults, but only one
    # set of config options. Swap the config options if we have booted
    # on the other chip.
    if check_clock_config_matches_chip():
        logger.info('Adjusted clock speeds for new chipset.')
        reboot_now = True

    # If we are in NOOBS mode, remove the config lines generated by noobs
    # because they duplicate our config entries and override them and
    # we expect only one instance of a config entry.
    if remove_noobs_defaults():
        logger.info('Removed NOOBS config.txt defaults.')
        reboot_now = True

    # If we need to set anything to do with config.txt, reboot
    if reboot_now:
        end_config_transaction()
        logger.debug('Changes were made to config.txt, rebooting.')
        reboot(dry_run=dry_run)
        return RC_SUCCESS

    # TODO: Why isn't this above the reboot and config modifications?
    if is_safe_boot():
        logger.info('In safe boot mode, restoring config.txt, skipping autoconfig.')
        safe_mode_restore_config()
        end_config_transaction()
        return RC_SUCCESS

    # Gather and log data about the current screen
    # screen_data = get_screen_information(dry_run=dry_run)
    # if verbose or dump_mode:
    #     print json.dumps(screen_data, indent=4)

    # If the display model cannot be retrieved it is a strong indication that
    # the screen is unflashed or the EDID is corrupt.
    model = get_edid_name()  # TODO: or 'uSK'
    if not model:
        logger.error('Could not get the model of the screen. Will use config.txt defaults.')
        return RC_EDID_NO_MODEL

    # Check if the screen was already configured by looking for the hdmi_mode option
    # set for this display only.
    was_screen_configured = get_config_value(
        'hdmi_mode',
        config_filter=Filter.get_edid_filter(model),
        fallback=False,
        ignore_comments=True
    )
    if was_screen_configured and not force_mode:
        logger.debug('The unit was configured for this model already, exiting.')
        return RC_SUCCESS

    # Sanity checks, we need current screen status, EDID info, and list of display modes.
    status = get_status()
    if not status:
        logger.error('Could not determine current screen status, aborting.')
        return RC_EDID_NO_STATUS

    supported_modes = list_supported_modes(stringify=False)
    if not supported_modes:
        logger.error('Could not determine list of screen supported modes, aborting.')
        return RC_EDID_NO_SUPPORTED

    edid = get_edid()
    if not edid:
        logger.error('No EDID found. Set resolution for an unflashed SK.')
        reboot(dry_run=dry_run)
        return RC_SUCCESS

    # override modes, calculate is_monitor
    override_models(edid, model)
    calculate_is_monitor(edid)

    # Fix HDMI audio status.
    if not edid['hdmi_audio'] and is_HDMI():
        logger.info('HDMI audio not supported on this screen, changing to analogue')
        if not dry_run:
            set_to_HDMI(False)

    # Calculate changes needed.
    # changes = compare_and_set_mode(edid, status)
    changes = compare_and_set_full_range(edid, status)
    changes = changes or compare_and_set_overscan(edid, status)

    if is_screen_kit():
        changes = set_resolution_for_screen_kit(supported_modes)
    else:
        changes = compare_and_set_optimal_resolution(edid, status, supported_modes, verbose)

    if changes:
        # write comment to config
        set_config_comment('kano_screen_used', model)
        end_config_transaction()

        reboot(dry_run=dry_run)

    return RC_SUCCESS


def ensure_correct_browser(dry_run=False):
    """
    Makes sure we point to the supported browser
    depending on the Raspberry model performance.
    """
    browser_link = 'x-www-browser'

    model = get_rpi_model()
    arch = get_board_property(model, 'arch')

    chromium_support = arch not in ['armv6']
    browser = 'chromium-browser' if chromium_support else 'epiphany-browser'

    logger.info("Set browser to be: {}".format(browser))
    if dry_run:
        run_cmd('update-alternatives --set {} /usr/bin/{}'.format(browser_link, browser))


# def get_screen_information(screen_log_path='/boot/screen.log', dry_run=False):
    """
    TODO: Decide what to do with this.
    Retrieves the information about the current screen.
    The data will be logged to the bootpartition for
    troubleshooting purposes.
    """
    # info = {
    #     "edid": get_edid(),
    #     "model": get_model(),
    #     "status": get_status(),
    #     "supported": list_supported_modes(stringify=False)
    # }

    # if not dry_run:
    #     with open(screen_log_path, 'w') as f:
    #         json.dump(info, f, sort_keys=True, indent=4, separators=(',', ': '))

    # return info


def override_models(edid, model):
    """
    This function sets specific modes for screens that require special treatment.

    TODO: Description
    """
    overrides = {
        '32V3H-H6A': {'target_group': 'DMT', 'target_mode': 16, 'is_monitor': True},
        'AS4637_______': {'target_group': 'DMT', 'target_mode': 16, 'is_monitor': True},
        'BMD_HDMI': {'target_group': 'CEA', 'target_mode': 33, 'is_monitor': True},
    }

    if model not in overrides:
        return

    # Set the configured options for the model to the EDID of the given screen.
    for option, value in overrides[model].iteritems():
        edid[option] = value


def calculate_is_monitor(edid):
    """
    TODO: What is this for?
    """
    edid['target_full_range'] = edid['is_monitor']


def compare_and_set_full_range(edid, status, model, dry_run=False):
    """
    Returns True if full range is changed

    TODO: What is this for?
    """
    if status['full_range'] == edid['target_full_range']:
        logger.debug('Config full range change not needed.')
        return False

    hdmi_pixel_encoding = 2 if edid['target_full_range'] else 0

    logger.info(
        'Config full range change needed. Setting hdmi_pixel_encoding to {}'
        .format(hdmi_pixel_encoding)
    )
    if dry_run:
        return True

    set_config_value(
        'hdmi_pixel_encoding',
        hdmi_pixel_encoding,
        config_filter=Filter.get_edid_filter(model)
    )
    return True


def compare_and_set_overscan(edid, status, model, dry_run=False):
    """
    Returns True if overscan is changed

    TODO: Description
    """
    if status['overscan'] == edid['target_overscan']:
        logger.debug('Config overscan change not needed.')
        return False

    if edid['target_overscan']:
        disable_overscan = 0
        overscan_value = -48  # TODO: where does this value come from?
    else:
        disable_overscan = 1
        overscan_value = 0

    logger.info(
        'Overscan change needed. Setting disable_overscan to {} and overscan to {}'
        .format(disable_overscan, overscan_value)
    )
    if dry_run:
        return True

    set_config_value(
        'disable_overscan',
        disable_overscan,
        config_filter=Filter.get_edid_filter(model)
    )
    for overscan in ['overscan_left', 'overscan_right', 'overscan_top', 'overscan_bottom']:
        set_config_value(
            overscan,
            overscan_value,
            config_filter=Filter.get_edid_filter(model)
        )
    return True


def compare_and_set_optimal_resolution(edid, status, model, dry_run=False):
    """
    TODO: Description
    """
    if status['group'] == edid['target_group'] and \
       status['mode'] == edid['target_mode']:
        logger.info('mode change not needed')
        return False
    else:
        logger.info('mode change needed')
        modes = '{} {}'.format(edid['target_group'], edid['target_mode'])
        logger.info('setting mode: {}'.format(modes))

        set_hdmi_mode(edid['target_group'], edid['target_mode'])
        return True


def get_optimal_resolution(edid, supported_modes):
    """
    TODO: Description
    """
    PREFERRED_RESOLUTIONS = {
        '4:3': [
            {'width': 1280, 'height': 960},
            {'width': 1024, 'height': 768},
        ],
        '16:9': [
            {'width': 1366, 'height': 768},
            {'width': 1360, 'height': 768},
            {'width': 1280, 'height': 720},
        ],
        '16:10': [
            {'width': 1280, 'height': 800},
            {'width': 1440, 'height': 900},
        ],
    }

    optimal_resolution = None

    # Split the resolution into width and height.
    # TODO: This should be moved to system.display.parse_edid
    parts = edid['preferred_res'].strip('p').split('x')
    edid['preferred_width'] = int(parts[0])
    edid['preferred_height'] = int(parts[1])

    # Set the preferred aspect ratio for the preferred resolution.
    # The easiest conversion would be to look through supported resolutions, but it's
    # not the most comprehensive way. Hopefully, the preferred mode should be supported.
    for mode in supported_modes:
        if mode['mode'] == edid['preferred_mode'] and \
           mode['group'] == edid['preferred_group']:

            edid['preferred_aspect_ratio'] = mode['aspect']

    if 'preferred_aspect_ratio' not in edid:
        return

    for resolution in PREFERRED_RESOLUTIONS[edid['preferred_aspect_ratio']]:
        for mode in supported_modes:
            if resolution['width'] == edid['preferred_width'] and \
               resolution['height'] == edid['preferred_height']:

            optimal_resolution = resolution
            break

    optimal_resolution = optimal_resolution or {
        'width': edid['preferred_width'],
        'height': edid['preferred_height']
    }
    return optimal_resolution


def reboot(dry_run=False):
    """
    Flush logs to disk and reboot the kit

    TODO: Description
    """
    if not dry_run:
        logger.sync()
        run_cmd('kano-checked-reboot changes systemctl reboot --force')


if __name__ == '__main__':
    logger.force_log_level('info')

    if os.geteuid() == 0:
        logger.error('Program must be executed with root priviledges.')
        sys.exit(RC_REQUIRES_ROOT)

    try:
        args = docopt.docopt(__doc__)
    except docopt.DocoptExit:
        print __doc__
        sys.exit(RC_INCORRECT_ARGS)

    sys.exit(main(args) or RC_SUCCESS)
