#!/usr/bin/env python

# kano-settings-onboot
#
# Copyright (C) 2014-2017 Kano Computing Ltd.
# License: http://www.gnu.org/licenses/gpl-2.0.txt GNU GPL v2
#
# Kano OS settings-related script executed at bootup.
#
# It ensures that the following characteristics are configured correctly:
#   1. Corrupt /boot/config.txt file
#   2. Launches OS into Safe Mode
#   3. CPU clock speeds for moving an SD from one Pi to another (TODO: remove this)
#   4. Removes configurations made by an image built with NOOBS
#   5. The default browser is set accordingly (Chromium or Midori)
#   6. Correct ALSA volume levels on P0 CKC speaker
#   7. Lower default resolution for added performance
#
# When changes that require a reboot to take effect were made, it calls onto
# the kano-checked-reboot script to do so.


"""
kano-settings-onboot Kano OS settings-related script executed at bootup.

Usage:
    kano-settings-onboot [options]

Options:
    -f, --force     Reconfigure settings even when the status says it's not needed.
    -s, --dry-run   Execute the script, but do not apply any changes.
    -h, --help      Show this message.
"""


import os
import sys
import docopt

# Allows for testing this module from a local repository clone
if __name__ == '__main__' and __package__ is None:
    dir_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
    if dir_path != '/usr':
        sys.path.insert(0, dir_path)

from kano.utils.shell import run_cmd
from kano.utils.hardware import get_rpi_model, get_board_property
from kano.logging import logger
from kano_pi_hat.ck2_pro_hat import CK2ProHat

from kano_settings.system.display import get_status, get_edid_name, \
    get_edid, list_supported_modes, override_models, compare_and_set_full_range, \
    compare_and_set_overscan, compare_and_set_optimal_resolution
from kano_settings.system.boot_config.boot_config_filter import Filter
from kano_settings.boot_config import is_safe_boot, safe_mode_restore_config, \
    remove_noobs_defaults, end_config_transaction, check_corrupt_config, get_config_value
from kano_settings.system.audio import is_HDMI, set_to_HDMI, restart_alsa, \
    set_alsa_config_max_dB
from kano_settings.system.overclock_chip_support import check_clock_config_matches_chip

from kano_settings.return_codes import RC_SUCCESS, RC_REQUIRES_ROOT, RC_INCORRECT_ARGS, \
    RC_EDID_NO_MODEL, RC_EDID_NO_STATUS, RC_EDID_NO_SUPPORTED, RC_NO_EDID


DEFAULT_CKC_MAX_DB = -11.9


def main(args):

    force_mode = args['--force']
    dry_run = args['--dry-run']

    reboot_required = False

    # Check for corrupt config file.
    if check_corrupt_config():
        logger.warning('Found corrupt config file! Restored to default.')
        reboot(dry_run=dry_run)
        return RC_SUCCESS

    # Check for switch to Safe Mode to debug OS issues.
    if is_safe_boot():
        logger.info('In safe boot mode, restoring config.txt, skipping autoconfig.')
        safe_mode_restore_config()
        end_config_transaction()
        return RC_SUCCESS

    # Rpi1 and Rpi2 have different clock rate defaults, but only one
    # set of config options. Swap the config options if we have booted
    # on the other chip.
    if check_clock_config_matches_chip():
        logger.info('Adjusted clock speeds for new chipset.')
        reboot_required = True

    # If we are in NOOBS mode, remove the config lines generated by noobs
    # because they duplicate our config entries and override them and
    # we expect only one instance of a config entry.
    if remove_noobs_defaults():
        logger.info('Removed NOOBS config.txt defaults.')
        reboot_required = True

    # TODO: Is this still required?
    ensure_correct_browser(dry_run=dry_run)

    # Correct the maximum volume gain for CKC.
    ensure_correct_volume_levels()

    # Gather and log data about the current screen.
    # screen_data = get_screen_information(dry_run=dry_run)
    # if verbose or dump_mode:
    #     print json.dumps(screen_data, indent=4)

    # Lower the screen preferred resolution.
    (rv, rc) = ensure_optimal_screen_resolution(dry_run=dry_run, force_mode=force_mode)
    reboot_required = reboot_required or rv
    if rc != RC_SUCCESS:
        return rc

    # ... and reboot if needed.
    if reboot_required:
        logger.info('Made changes that require a reboot.')
        end_config_transaction()
        reboot(dry_run=dry_run)

    return rc or RC_SUCCESS


def ensure_correct_browser(dry_run=False):
    """
    Makes sure we point to the supported browser
    depending on the Raspberry model performance.
    """
    browser_link = 'x-www-browser'

    model = get_rpi_model()
    arch = get_board_property(model, 'arch')

    chromium_support = arch not in ['armv6']
    browser = 'chromium-browser' if chromium_support else 'epiphany-browser'

    logger.info("Set browser to be: {}".format(browser))
    if dry_run:
        run_cmd('update-alternatives --set {} /usr/bin/{}'.format(browser_link, browser))


def ensure_correct_volume_levels():
    """
    Sets the default max_dB option in ALSA for CKC only.
    """
    ck2_pro_hat = CK2ProHat()
    ck2_pro_hat.initialise()
    changes = False

    if ck2_pro_hat.is_connected():
        changes = set_alsa_config_max_dB(DEFAULT_CKC_MAX_DB)
        logger.debug('On CKC, ALSA max_dB changes {}'.format(changes))

    if changes:
        restart_alsa()


# def get_screen_information(screen_log_path='/boot/screen.log', dry_run=False):
    """
    TODO: Decide what to do with this.

    Retrieves the information about the current screen.
    The data will be logged to the bootpartition for
    troubleshooting purposes.
    """
    # info = {
    #     "edid": get_edid(),
    #     "model": get_model(),
    #     "status": get_status(),
    #     "supported": list_supported_modes(stringify=False)
    # }

    # if not dry_run:
    #     with open(screen_log_path, 'w') as f:
    #         json.dump(info, f, sort_keys=True, indent=4, separators=(',', ': '))

    # return info


def ensure_optimal_screen_resolution(dry_run=False, force_mode=False):
    """
    Set a lower resolution than the screen preferred one.

    This is used in order to increase performance for anything GPU heavy.
    It uses EDID filters in config.txt to configure the current screen if
    it hasn't been configured already. The function preserves the display
    mode (CEA or DMT), aspect ratio, refresh rate, etc.

    Args:
        dry_run - bool run the function, but do not apply any changes
        force_mode - bool reconfigure settings even when the status says it's not needed

    Returns:
        (reboot_required, rc) - tuple of bool whether changes which require a reboot
            were made and int as a return code if something went wrong
    """
    reboot_required = False

    # If the display model cannot be retrieved it is a strong indication that
    # the screen is unflashed or the EDID is corrupt.
    model = get_edid_name()
    if not model:
        logger.error('Could not get the model of the screen. Will use config.txt defaults.')
        return (reboot_required, RC_EDID_NO_MODEL)

    # Check if the screen was already configured by looking for the hdmi_mode option
    # set for this display only.
    was_screen_configured = get_config_value(
        'hdmi_mode',
        config_filter=Filter.get_edid_filter(model),
        fallback=False,
        ignore_comments=True
    )
    if was_screen_configured and not force_mode:
        logger.debug('The unit was configured for this model already, exiting.')
        return (reboot_required, RC_SUCCESS)

    # Sanity checks, we need current screen status, EDID info, and list of display modes.
    status = get_status()
    if not status:
        logger.error('Could not determine current screen status, aborting.')
        return (reboot_required, RC_EDID_NO_STATUS)

    supported_modes = list_supported_modes()
    if not supported_modes:
        logger.error('Could not determine list of screen supported modes, aborting.')
        return (reboot_required, RC_EDID_NO_SUPPORTED)

    edid = get_edid()
    if not edid:
        logger.error('No EDID found. Relying on the defaults already set in config.')
        return (reboot_required, RC_NO_EDID)

    # Apply any corrections to the EDID data and set if screen is monitor.
    override_models(edid, model)
    calculate_is_monitor(edid)

    # Fix HDMI audio status.
    if not edid['hdmi_audio'] and is_HDMI():
        logger.info('HDMI audio not supported on this screen, changing to analogue.')
        if not dry_run:
            set_to_HDMI(False)

    # Calculate changes needed...
    changes = compare_and_set_full_range(edid, status, model, dry_run=dry_run, force=force_mode)
    reboot_required = reboot_required or changes

    changes = compare_and_set_overscan(edid, status, model, dry_run=dry_run, force=force_mode)
    reboot_required = reboot_required or changes

    changes = compare_and_set_optimal_resolution(edid, status, supported_modes, dry_run=dry_run, force=force_mode)
    reboot_required = reboot_required or changes

    return (reboot_required, RC_SUCCESS)


def calculate_is_monitor(edid):
    """
    TODO: What is this for?
    """
    edid['target_full_range'] = edid['is_monitor']


def reboot(dry_run=False):
    """
    Flush logs to disk and reboot the kit.
    """
    if not dry_run:
        logger.sync()
        run_cmd('kano-checked-reboot changes systemctl reboot --force')


if __name__ == '__main__':
    logger.force_log_level('info')

    if os.getuid() != 0:
        logger.error('Program must be executed with root priviledges.')
        sys.exit(RC_REQUIRES_ROOT)

    try:
        args = docopt.docopt(__doc__)
    except docopt.DocoptExit:
        print __doc__
        sys.exit(RC_INCORRECT_ARGS)

    sys.exit(main(args) or RC_SUCCESS)
