#!/usr/bin/env python

# check-enable-ssh
#
# Copyright (C) 2017 Kano Computing Ltd.
# License: http://www.gnu.org/licenses/gpl-2.0.txt GNU GPL v2
#
# TODO: Description


"""
kano-settings-onboot TODO: Description

Usage:
    kano-settings-onboot [options]

Options:
    -f, --force         TODO: Description
    -s, --dry-run       TODO: Description
    -h, --help          Show this message.
"""


import os
import sys
import json
import docopt

# Allows for testing this module from a local repository clone
if __name__ == '__main__' and __package__ is None:
    dir_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
    if dir_path != '/usr':
        sys.path.insert(0, dir_path)

from kano.utils.shell import run_cmd
from kano.utils.hardware import get_rpi_model, get_board_property
from kano.logging import logger

from kano_settings.system.display import get_status, get_model, set_hdmi_mode, \
    get_edid, is_mode_fallback, set_safeboot_mode, set_screen_value, \
    list_supported_modes, is_screen_kit
from kano_settings.boot_config import set_config_value, set_config_comment, \
    get_config_comment, get_config_value, has_config_comment, \
    enforce_pi, is_safe_boot, safe_mode_backup_config, \
    safe_mode_restore_config, remove_noobs_defaults, set_dry_run, \
    end_config_transaction, check_corrupt_config
from kano_settings.system.audio import is_HDMI, set_to_HDMI
from kano_settings.system.overclock_chip_support import check_clock_config_matches_chip

from kano_settings.return_codes import RC_SUCCESS, RC_REQUIRES_ROOT, RC_INCORRECT_ARGS, \
    RC_EDID_NO_STATUS, RC_EDID_NO_SUPPORTED


def main(args):

    force_mode = args['--force']
    dry_run = args['--dry-run']

    # TODO: Move this task away, it is not related to screen management
    ensure_correct_browser(dry_run=dry_run)

    # Check for corrupt config file
    if check_corrupt_config():
        logger.error('Found corrupt config file! Restored to default.')
        reboot_now = True

    # Rpi1 and Rpi2 have different clock rate defaults, but only one
    # set of config options. Swap the config options if we have booted
    # on the other chip.
    if check_clock_config_matches_chip():
        logger.info('Adjusted clock speeds for new chipset.')
        reboot_now = True

    # If we are in NOOBS mode, remove the config lines generated by noobs
    # because they duplicate our config entries and override them and
    # we expect only one instance of a config entry.
    if remove_noobs_defaults():
        logger.info('Removed NOOBS config.txt defaults.')
        reboot_now = True

    # If we need to set anything to do with config.txt, reboot
    if reboot_now:
        end_config_transaction()
        logger.debug('Changes were made to config.txt, rebooting.')
        reboot(dry_run=dry_run)
        return RC_SUCCESS

    # TODO: Why isn't this above the reboot and config modifications?
    if is_safe_boot():
        logger.info('In safe boot mode, restoring config.txt, skipping autoconfig.')
        safe_mode_restore_config()
        end_config_transaction()
        return RC_SUCCESS

    # Gather and log data about the current screen
    screen_data = get_screen_information(dry_run=dry_run)
    # if verbose or dump_mode:
    #     print json.dumps(screen_data, indent=4)

    # Sanity checks, we need current screen status and EDID info
    model = screen_data['model']  # TODO: or 'uSK'
    logger.info('Screen model: {}'.format(model))
    was_screen_configured = get_config_comment('kano_screen_used', model)
    logger.info('is comment kano_screen_used({})? {}'.format(model, was_screen_configured))

    if was_screen_configured:
        logger.info('The unit was configured for this model already, exiting.')
        return RC_SUCCESS

    status = screen_data['status']
    if not status:
        logger.debug("Could not determine current screen status, aborting.")
        return RC_EDID_NO_STATUS

    supported = screen_data['supported']
    if not supported:
        logger.debug("Could not determine list of screen supported modes, aborting.")
        return RC_EDID_NO_SUPPORTED

    edid = screen_data['edid']
    if not edid:
        if set_resolution_for_unflashed_screen(status):
            # TODO: enable the lines below
            # set_config_comment('kano_screen_used', 'uSK')
            # end_config_transaction()
            logger.info('No EDID found. Set resolution for an unflashed SK.')
            reboot(dry_run=dry_run)
            return RC_SUCCESS

    # If the hdmi_group and hdmi_mode values are set explicitly then skip the detection.
    if get_config_value('hdmi_group', ignore_comments=True) != 0 and \
       get_config_value('hdmi_mode', ignore_comments=True) != 0:

        if not force_mode and was_screen_configured:
            # The screen is either the same or not set at all
            logger.info('Explicit HDMI configuration detected, exiting.')
            return RC_SUCCESS
        else:
            logger.info('New screen was detected, reconfiguring...')

    # override modes, calculate is_monitor
    override_models(edid, model)
    calculate_is_monitor(edid)

    # Fix HDMI audio status.
    if not edid['hdmi_audio'] and is_HDMI():
        logger.info('HDMI audio not supported on this screen, changing to analogue')
        if not dry_run:
            set_to_HDMI(False)

    # Calculate changes needed.
    changes = compare_and_set_mode(edid, status)
    changes = changes or compare_and_set_full_range(edid, status)
    changes = changes or compare_and_set_overscan(edid, status)
    resolution_changes = (
        set_resolution_for_screen_kit(supported) or
        compare_and_set_optimal_resolution(edid, status, supported, verbose)
    )
    changes = changes or resolution_changes

    if changes:
        # write comment to config
        set_config_comment('kano_screen_used', model)
        end_config_transaction()

        reboot(dry_run=dry_run)

    return RC_SUCCESS


def ensure_correct_browser(dry_run=False):
    """
    Makes sure we point to the supported browser
    depending on the Raspberry model performance.
    """
    browser_link = 'x-www-browser'

    model = get_rpi_model()
    arch = get_board_property(model, 'arch')

    chromium_support = arch not in ['armv6']
    browser = 'chromium-browser' if chromium_support else 'epiphany-browser'

    logger.debug("Browser should be: {}".format(browser))
    if dry_run:
        run_cmd('update-alternatives --set {} /usr/bin/{}'.format(browser_link, browser))


def get_screen_information(screen_log_path='/boot/screen.log', dry_run=False):
    """
    Retrieves the information about the current screen.
    The data will be logged to the bootpartition for
    troubleshooting purposes.
    """
    info = {
        "edid": get_edid(),
        "model": get_model(),
        "status": get_status(),
        "supported": list_supported_modes(stringify=False)
    }

    if not dry_run:
        with open(screen_log_path, 'w') as f:
            json.dump(info, f, sort_keys=True, indent=4, separators=(',', ': '))

    return info


def override_models(edid, model):
    """
    This function sets specific modes for screens that require special treatment.

    TODO: Description
    """
    overrides = {
        '32V3H-H6A': {'target_group': 'DMT', 'target_mode': 16, 'is_monitor': True},
        'AS4637_______': {'target_group': 'DMT', 'target_mode': 16, 'is_monitor': True},
        'BMD_HDMI': {'target_group': 'CEA', 'target_mode': 33, 'is_monitor': True},
    }

    if model not in overrides:
        return

    # Set the configured options for the model to the EDID of the given screen.
    for option, value in overrides[model].iteritems():
        edid[option] = value


def reboot(dry_run=False):
    """
    Flush logs to disk and reboot the kit

    TODO: Description
    """
    if not dry_run:
        logger.sync()
        run_cmd('kano-checked-reboot changes systemctl reboot --force')


if __name__ == '__main__':
    logger.force_log_level('info')

    if os.geteuid() == 0:
        logger.error('Program must be executed with root priviledges.')
        sys.exit(RC_REQUIRES_ROOT)

    try:
        args = docopt.docopt(__doc__)
    except docopt.DocoptExit:
        print __doc__
        sys.exit(RC_INCORRECT_ARGS)

    sys.exit(main(args) or RC_SUCCESS)
